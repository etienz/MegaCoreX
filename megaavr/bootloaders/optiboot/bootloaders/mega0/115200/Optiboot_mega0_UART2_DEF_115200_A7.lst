
bootloaders/mega0/115200/Optiboot_mega0_UART2_DEF_115200_A7.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00802800  000001ba  0000026e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001ba  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .application  00000032  00000200  00000200  00000270  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .version      00000002  000001fe  000001fe  0000026e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .fuse         00000009  00820000  00820000  000002a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .comment      00000011  00000000  00000000  000002ab  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000038  00000000  00000000  000002bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001049  00000000  00000000  000002f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000002af  00000000  00000000  0000133d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000003f1  00000000  00000000  000015ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000ac  00000000  00000000  000019e0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000a04  00000000  00000000  00001a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000241  00000000  00000000  00002490  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000028  00000000  00000000  000026d1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pre_main>:
/* everything that needs to run VERY early */
void pre_main (void) {
    // Allow convenient way of calling do_spm function - jump table,
    //   so entry to this function will always be here, indepedent
    //    of compilation, features, etc
    __asm__ __volatile__ (
   0:	01 c0       	rjmp	.+2      	; 0x4 <main>
   2:	cd c0       	rjmp	.+410    	; 0x19e <do_nvmctrl>

00000004 <main>:
    //
    // Optiboot C code makes the following assumptions:
    //  No interrupts will execute
    //  SP points to RAMEND

    __asm__ __volatile__ ("clr __zero_reg__"); // known-zero required by avr-libc
   4:	11 24       	eor	r1, r1
#define RESET_EXTERNAL (/*RSTCTRL_EXTRF_bm|*/RSTCTRL_UPDIRF_bm|RSTCTRL_SWRF_bm)
#if defined (USERROW_LOGIC)
    // Check for UPI reset for bootloading after programming bootloader
    if ((BOOTLOADER_KEY_ADDR == BOOTLOADER_KEY) && ((HARD_PORT.IN & 0xf) != HARD_RECOVERY_KEY))
   6:	80 91 1f 13 	lds	r24, 0x131F	; 0x80131f <__TEXT_REGION_LENGTH__+0x70131f>
   a:	8b 3e       	cpi	r24, 0xEB	; 235
   c:	39 f4       	brne	.+14     	; 0x1c <main+0x18>
   e:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x700408>
  12:	8f 70       	andi	r24, 0x0F	; 15
  14:	19 f0       	breq	.+6      	; 0x1c <main+0x18>
        * to a global variable.
        */
        //__asm__ __volatile__("  mov r2, %0\n" :: "r"(ch));

        // switch on watchdog
        watchdogConfig(WDT_PERIOD_1KCLK_gc);//WDT_PERIOD_OFF_gc);//
  16:	88 e0       	ldi	r24, 0x08	; 8
  18:	aa d0       	rcall	.+340    	; 0x16e <watchdogConfig>
        app();
  1a:	f2 d0       	rcall	.+484    	; 0x200 <app>
  1c:	a8 95       	wdr
        );
    }
  }
#endif // Fancy reset cause stuff

    watchdogReset();
  1e:	a0 9a       	sbi	0x14, 0	; 20
    //_PROTECTED_WRITE(CLKCTRL.MCLKCTRLB, CLKCTRL_PDIV_6X_gc);  // full speed clock

    MYUART_TXPORT.DIR |= MYUART_TXPIN; // set TX pin to output
  20:	a8 9a       	sbi	0x15, 0	; 21
    MYUART_TXPORT.OUT |= MYUART_TXPIN;  // and "1" as per datasheet
  22:	10 92 e2 05 	sts	0x05E2, r1	; 0x8005e2 <__TEXT_REGION_LENGTH__+0x7005e2>
#if defined (MYUART_PMUX_VAL)
    MYPMUX_REG = MYUART_PMUX_VAL;  // alternate pinout to use
  26:	80 91 82 12 	lds	r24, 0x1282	; 0x801282 <__TEXT_REGION_LENGTH__+0x701282>
#endif
    if ((FUSE_OSCCFG & FUSE_FREQSEL_gm) == FREQSEL_16MHZ_gc) {
  2a:	83 70       	andi	r24, 0x03	; 3
  2c:	81 30       	cpi	r24, 0x01	; 1
  2e:	11 f5       	brne	.+68     	; 0x74 <__SREG__+0x35>
  30:	8c e5       	ldi	r24, 0x5C	; 92
	    MYUART.BAUD = BAUD_SETTING_16;
  32:	90 e0       	ldi	r25, 0x00	; 0
  34:	80 93 48 08 	sts	0x0848, r24	; 0x800848 <__TEXT_REGION_LENGTH__+0x700848>
    } else {
	    MYUART.BAUD = BAUD_SETTING_20;//694;
  38:	90 93 49 08 	sts	0x0849, r25	; 0x800849 <__TEXT_REGION_LENGTH__+0x700849>
  3c:	81 e0       	ldi	r24, 0x01	; 1
    }
    MYUART.DBGCTRL = 1;  // run during debug
  3e:	80 93 4b 08 	sts	0x084B, r24	; 0x80084b <__TEXT_REGION_LENGTH__+0x70084b>
  42:	83 e0       	ldi	r24, 0x03	; 3
    MYUART.CTRLC = (USART_CHSIZE_gm & USART_CHSIZE_8BIT_gc);  // Async, Parity Disabled, 1 StopBit
  44:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
  48:	10 92 45 08 	sts	0x0845, r1	; 0x800845 <__TEXT_REGION_LENGTH__+0x700845>
    MYUART.CTRLA = 0;  // Interrupts: all off
  4c:	80 ec       	ldi	r24, 0xC0	; 192
    MYUART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;
  4e:	80 93 46 08 	sts	0x0846, r24	; 0x800846 <__TEXT_REGION_LENGTH__+0x700846>

    // Set up watchdog to trigger after a bit
    //  (nominally:, 1s for autoreset, longer for manual)
    watchdogConfig(WDTPERIOD);
  52:	88 e0       	ldi	r24, 0x08	; 8
  54:	8c d0       	rcall	.+280    	; 0x16e <watchdogConfig>
  56:	8b ee       	ldi	r24, 0xEB	; 235
        else if (ch == STK_LEAVE_PROGMODE) { /* 'Q' */
            // Adaboot no-wait mod
            verifySpace();
#if defined (USERROW_LOGIC)
            /* Clear boot request*/
            BOOTLOADER_KEY_ADDR = BOOTLOADER_KEY;
  58:	c8 2e       	mov	r12, r24
  5a:	0d e9       	ldi	r16, 0x9D	; 157
            _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
  5c:	93 e0       	ldi	r25, 0x03	; 3
  5e:	d9 2e       	mov	r13, r25
#endif

    /* Forever loop: exits by causing WDT reset */
    for (;;) {
        /* get character from UART */
        ch = getch();
  60:	7a d0       	rcall	.+244    	; 0x156 <getch>

        if(ch == STK_GET_PARAMETER) {
  62:	81 34       	cpi	r24, 0x41	; 65
            which = getch();
  64:	91 f4       	brne	.+36     	; 0x8a <__SREG__+0x4b>
  66:	77 d0       	rcall	.+238    	; 0x156 <getch>
  68:	18 2f       	mov	r17, r24
            verifySpace();
  6a:	8a d0       	rcall	.+276    	; 0x180 <verifySpace>
  6c:	12 38       	cpi	r17, 0x82	; 130
            /*
            * Send optiboot version as "SW version"
            * Note that the references to memory are optimized away.
            */
            if (which == STK_SW_MINOR) {
  6e:	29 f4       	brne	.+10     	; 0x7a <__SREG__+0x3b>
  70:	80 e0       	ldi	r24, 0x00	; 0
        }
        else if(ch == STK_UNIVERSAL) {
#ifndef RAMPZ
            // UNIVERSAL command is ignored
            getNch(4);
            putch(0x00);
  72:	07 c0       	rjmp	.+14     	; 0x82 <__SREG__+0x43>
  74:	83 e7       	ldi	r24, 0x73	; 115
    MYPMUX_REG = MYUART_PMUX_VAL;  // alternate pinout to use
#endif
    if ((FUSE_OSCCFG & FUSE_FREQSEL_gm) == FREQSEL_16MHZ_gc) {
	    MYUART.BAUD = BAUD_SETTING_16;
    } else {
	    MYUART.BAUD = BAUD_SETTING_20;//694;
  76:	90 e0       	ldi	r25, 0x00	; 0
  78:	dd cf       	rjmp	.-70     	; 0x34 <__CCP__>
            * Send optiboot version as "SW version"
            * Note that the references to memory are optimized away.
            */
            if (which == STK_SW_MINOR) {
                putch(optiboot_version & 0xFF);
            } else if (which == STK_SW_MAJOR) {
  7a:	89 e0       	ldi	r24, 0x09	; 9
  7c:	11 38       	cpi	r17, 0x81	; 129
            } else {
            /*
            * GET PARAMETER returns a generic 0x03 reply for
            * other parameters - enough to keep Avrdude happy
            */
                putch(0x03);
  7e:	09 f0       	breq	.+2      	; 0x82 <__SREG__+0x43>
  80:	83 e0       	ldi	r24, 0x03	; 3
        }
        else {
            // This covers the response to commands like STK_ENTER_PROGMODE
            verifySpace();
        }
        putch(STK_OK);
  82:	62 d0       	rcall	.+196    	; 0x148 <putch>
  84:	80 e1       	ldi	r24, 0x10	; 16
  86:	60 d0       	rcall	.+192    	; 0x148 <putch>
#endif

    /* Forever loop: exits by causing WDT reset */
    for (;;) {
        /* get character from UART */
        ch = getch();
  88:	eb cf       	rjmp	.-42     	; 0x60 <__SREG__+0x21>
            * other parameters - enough to keep Avrdude happy
            */
                putch(0x03);
            }
        }
        else if(ch == STK_SET_DEVICE) {
  8a:	82 34       	cpi	r24, 0x42	; 66
  8c:	19 f4       	brne	.+6      	; 0x94 <__SREG__+0x55>
            // SET DEVICE is ignored
            getNch(20);
  8e:	84 e1       	ldi	r24, 0x14	; 20
        }
        else if(ch == STK_SET_DEVICE_EXT) {
            // SET DEVICE EXT is ignored
            getNch(5);
  90:	7f d0       	rcall	.+254    	; 0x190 <getNch>
  92:	f8 cf       	rjmp	.-16     	; 0x84 <__SREG__+0x45>
        }
        else if(ch == STK_SET_DEVICE) {
            // SET DEVICE is ignored
            getNch(20);
        }
        else if(ch == STK_SET_DEVICE_EXT) {
  94:	85 34       	cpi	r24, 0x45	; 69
            // SET DEVICE EXT is ignored
            getNch(5);
  96:	11 f4       	brne	.+4      	; 0x9c <__SREG__+0x5d>
  98:	85 e0       	ldi	r24, 0x05	; 5
        }
        else if(ch == STK_LOAD_ADDRESS) {
  9a:	fa cf       	rjmp	.-12     	; 0x90 <__SREG__+0x51>
  9c:	85 35       	cpi	r24, 0x55	; 85
            // LOAD ADDRESS
            address.bytes[0] = getch();
  9e:	31 f4       	brne	.+12     	; 0xac <__SREG__+0x6d>
  a0:	5a d0       	rcall	.+180    	; 0x156 <getch>
            address.bytes[1] = getch();
  a2:	c8 2f       	mov	r28, r24
  a4:	58 d0       	rcall	.+176    	; 0x156 <getch>
            __asm__ __volatile__ ("jmp 0");    // Restart bootloader program without triggering resets
#endif
        }
        else {
            // This covers the response to commands like STK_ENTER_PROGMODE
            verifySpace();
  a6:	d8 2f       	mov	r29, r24
  a8:	6b d0       	rcall	.+214    	; 0x180 <verifySpace>
    /*          UPDI chips apparently have byte-addressable FLASH ?
            address.word *= 2; // Convert from word address to byte address
    */
            verifySpace();
        }
        else if(ch == STK_UNIVERSAL) {
  aa:	ec cf       	rjmp	.-40     	; 0x84 <__SREG__+0x45>
  ac:	86 35       	cpi	r24, 0x56	; 86
#ifndef RAMPZ
            // UNIVERSAL command is ignored
            getNch(4);
  ae:	19 f4       	brne	.+6      	; 0xb6 <__SREG__+0x77>
  b0:	84 e0       	ldi	r24, 0x04	; 4
  b2:	6e d0       	rcall	.+220    	; 0x190 <getNch>
            putch(0x00);
#endif
        }
        /* Write memory, length is big endian and is in bytes */
        else if(ch == STK_PROG_PAGE) {
  b4:	dd cf       	rjmp	.-70     	; 0x70 <__SREG__+0x31>
            // PROGRAM PAGE - any kind of page!

            GETLENGTH(length);
  b6:	84 36       	cpi	r24, 0x64	; 100
  b8:	b9 f4       	brne	.+46     	; 0xe8 <__SREG__+0xa9>
  ba:	4d d0       	rcall	.+154    	; 0x156 <getch>
  bc:	4c d0       	rcall	.+152    	; 0x156 <getch>
  be:	18 2f       	mov	r17, r24
            desttype = getch();
  c0:	4a d0       	rcall	.+148    	; 0x156 <getch>
  c2:	86 34       	cpi	r24, 0x46	; 70

            if (desttype == 'F') {
  c4:	79 f4       	brne	.+30     	; 0xe4 <__SREG__+0xa5>
  c6:	d0 5c       	subi	r29, 0xC0	; 192
                address.word += MAPPED_PROGMEM_START;
  c8:	46 d0       	rcall	.+140    	; 0x156 <getch>
                address.word += MAPPED_EEPROM_START;
            }
            // TODO: user row?

            do {
                *(address.bptr++) = getch();
  ca:	88 83       	st	Y, r24
  cc:	21 96       	adiw	r28, 0x01	; 1
  ce:	11 50       	subi	r17, 0x01	; 1
            } while (--length);
  d0:	d9 f7       	brne	.-10     	; 0xc8 <__SREG__+0x89>

            // Read command terminator, start reply
            verifySpace();
  d2:	56 d0       	rcall	.+172    	; 0x180 <verifySpace>

            /*
            * Actually Write the buffer to flash (and wait for it to finish.) */
            
            _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
  d4:	04 bf       	out	0x34, r16	; 52
  d6:	d0 92 00 10 	sts	0x1000, r13	; 0x801000 <__TEXT_REGION_LENGTH__+0x701000>
            while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
  da:	80 91 02 10 	lds	r24, 0x1002	; 0x801002 <__TEXT_REGION_LENGTH__+0x701002>
  de:	83 70       	andi	r24, 0x03	; 3
  e0:	e1 f7       	brne	.-8      	; 0xda <__SREG__+0x9b>
            desttype = getch();

            if (desttype == 'F') {
                address.word += MAPPED_PROGMEM_START;
            } else {
                address.word += MAPPED_EEPROM_START;
  e2:	d0 cf       	rjmp	.-96     	; 0x84 <__SREG__+0x45>
  e4:	dc 5e       	subi	r29, 0xEC	; 236
            _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
            while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
            ; // wait for flash and EEPROM not busy, just in case.            
        }
        /* Read memory block mode, length is big endian. */ 
        else if(ch == STK_READ_PAGE) {
  e6:	f0 cf       	rjmp	.-32     	; 0xc8 <__SREG__+0x89>
  e8:	84 37       	cpi	r24, 0x74	; 116
            GETLENGTH(length);
  ea:	91 f4       	brne	.+36     	; 0x110 <__SREG__+0xd1>
  ec:	34 d0       	rcall	.+104    	; 0x156 <getch>
  ee:	33 d0       	rcall	.+102    	; 0x156 <getch>
  f0:	18 2f       	mov	r17, r24

            desttype = getch();
  f2:	31 d0       	rcall	.+98     	; 0x156 <getch>
  f4:	f8 2e       	mov	r15, r24

            verifySpace();
  f6:	44 d0       	rcall	.+136    	; 0x180 <verifySpace>
            if (desttype == 'F') {
  f8:	86 e4       	ldi	r24, 0x46	; 70
  fa:	f8 12       	cpse	r15, r24
  fc:	07 c0       	rjmp	.+14     	; 0x10c <__SREG__+0xcd>
                address.word += MAPPED_PROGMEM_START;
  fe:	d0 5c       	subi	r29, 0xC0	; 192
                address.word += MAPPED_EEPROM_START;
            }
            // TODO: user row?

            do {
                putch(*(address.bptr++));
 100:	88 81       	ld	r24, Y
 102:	21 96       	adiw	r28, 0x01	; 1
 104:	21 d0       	rcall	.+66     	; 0x148 <putch>
            } while (--length);
 106:	11 50       	subi	r17, 0x01	; 1
 108:	d9 f7       	brne	.-10     	; 0x100 <__SREG__+0xc1>
 10a:	bc cf       	rjmp	.-136    	; 0x84 <__SREG__+0x45>

            verifySpace();
            if (desttype == 'F') {
                address.word += MAPPED_PROGMEM_START;
            } else {
                address.word += MAPPED_EEPROM_START;
 10c:	dc 5e       	subi	r29, 0xEC	; 236
 10e:	f8 cf       	rjmp	.-16     	; 0x100 <__SREG__+0xc1>
                putch(*(address.bptr++));
            } while (--length);
        }

        /* Get device signature bytes */
        else if(ch == STK_READ_SIGN) {
 110:	85 37       	cpi	r24, 0x75	; 117
 112:	51 f4       	brne	.+20     	; 0x128 <__SREG__+0xe9>
            // READ SIGN - return actual device signature from SIGROW
            // This enables the same binary to be ued on multiple chips.
            verifySpace();
 114:	35 d0       	rcall	.+106    	; 0x180 <verifySpace>
            putch(SIGROW_DEVICEID0);
 116:	80 91 00 11 	lds	r24, 0x1100	; 0x801100 <__TEXT_REGION_LENGTH__+0x701100>
 11a:	16 d0       	rcall	.+44     	; 0x148 <putch>
 11c:	80 91 01 11 	lds	r24, 0x1101	; 0x801101 <__TEXT_REGION_LENGTH__+0x701101>
            putch(SIGROW_DEVICEID1);
 120:	13 d0       	rcall	.+38     	; 0x148 <putch>
 122:	80 91 02 11 	lds	r24, 0x1102	; 0x801102 <__TEXT_REGION_LENGTH__+0x701102>
            putch(SIGROW_DEVICEID2);
 126:	ad cf       	rjmp	.-166    	; 0x82 <__SREG__+0x43>
 128:	81 35       	cpi	r24, 0x51	; 81
 12a:	09 f0       	breq	.+2      	; 0x12e <__SREG__+0xef>
        }
        else if (ch == STK_LEAVE_PROGMODE) { /* 'Q' */
 12c:	bd cf       	rjmp	.-134    	; 0xa8 <__SREG__+0x69>
 12e:	28 d0       	rcall	.+80     	; 0x180 <verifySpace>
 130:	c0 92 1f 13 	sts	0x131F, r12	; 0x80131f <__TEXT_REGION_LENGTH__+0x70131f>
            // Adaboot no-wait mod
            verifySpace();
 134:	04 bf       	out	0x34, r16	; 52
#if defined (USERROW_LOGIC)
            /* Clear boot request*/
            BOOTLOADER_KEY_ADDR = BOOTLOADER_KEY;
 136:	d0 92 00 10 	sts	0x1000, r13	; 0x801000 <__TEXT_REGION_LENGTH__+0x701000>
            _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
 13a:	80 91 02 10 	lds	r24, 0x1002	; 0x801002 <__TEXT_REGION_LENGTH__+0x701002>
 13e:	81 fd       	sbrc	r24, 1
            while(NVMCTRL.STATUS & NVMCTRL_EEBUSY_bm)
 140:	fc cf       	rjmp	.-8      	; 0x13a <__SREG__+0xfb>
 142:	81 e0       	ldi	r24, 0x01	; 1
 144:	14 d0       	rcall	.+40     	; 0x16e <watchdogConfig>
 146:	9e cf       	rjmp	.-196    	; 0x84 <__SREG__+0x45>

00000148 <putch>:
                ;
            watchdogConfig(WDT_PERIOD_8CLK_gc);
 148:	90 91 44 08 	lds	r25, 0x0844	; 0x800844 <__TEXT_REGION_LENGTH__+0x700844>
 14c:	95 ff       	sbrs	r25, 5
 14e:	fc cf       	rjmp	.-8      	; 0x148 <putch>


void putch (char ch) {
    while (0 == (MYUART.STATUS & USART_DREIF_bm))
	;
    MYUART.TXDATAL = ch;
 150:	80 93 42 08 	sts	0x0842, r24	; 0x800842 <__TEXT_REGION_LENGTH__+0x700842>
}
 154:	08 95       	ret

00000156 <getch>:

//#define ECHO

uint8_t getch (void) {
    uint8_t ch, flags;
    while (!(MYUART.STATUS & USART_RXCIF_bm))
 156:	80 91 44 08 	lds	r24, 0x0844	; 0x800844 <__TEXT_REGION_LENGTH__+0x700844>
 15a:	87 ff       	sbrs	r24, 7
 15c:	fc cf       	rjmp	.-8      	; 0x156 <getch>
	;
    flags = MYUART.RXDATAH;
 15e:	90 91 41 08 	lds	r25, 0x0841	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    ch = MYUART.RXDATAL;
 162:	80 91 40 08 	lds	r24, 0x0840	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
#ifdef ECHO
    putch(ch);
#endif
    if ((flags & USART_FERR_bm) == 0)
 166:	92 fd       	sbrc	r25, 2
 168:	01 c0       	rjmp	.+2      	; 0x16c <getch+0x16>
	    watchdogReset();
 16a:	a8 95       	wdr
#ifdef LED_DATA_FLASH
    LED_PORT.IN |= LED;
#endif

    return ch;
}
 16c:	08 95       	ret

0000016e <watchdogConfig>:
/*
 * Change the watchdog configuration.
 *  Could be a new timeout, could be off...
 */
void watchdogConfig (uint8_t x) {
    while(WDT.STATUS & WDT_SYNCBUSY_bm)
 16e:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__TEXT_REGION_LENGTH__+0x700101>
 172:	90 fd       	sbrc	r25, 0
 174:	fc cf       	rjmp	.-8      	; 0x16e <watchdogConfig>
	;  // Busy wait for sycnhronization is required!
    _PROTECTED_WRITE(WDT.CTRLA, x);
 176:	98 ed       	ldi	r25, 0xD8	; 216
 178:	94 bf       	out	0x34, r25	; 52
 17a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__TEXT_REGION_LENGTH__+0x700100>
}
 17e:	08 95       	ret

00000180 <verifySpace>:
    do getch(); while (--count);
    verifySpace();
}

void verifySpace () {
    if (getch() != CRC_EOP) {
 180:	ea df       	rcall	.-44     	; 0x156 <getch>
 182:	80 32       	cpi	r24, 0x20	; 32
 184:	19 f0       	breq	.+6      	; 0x18c <verifySpace+0xc>
        watchdogConfig(WDT_PERIOD_8CLK_gc);    // shorten WD timeout
 186:	81 e0       	ldi	r24, 0x01	; 1
 188:	f2 df       	rcall	.-28     	; 0x16e <watchdogConfig>
 18a:	ff cf       	rjmp	.-2      	; 0x18a <verifySpace+0xa>
        while (1)			      // and busy-loop so that WD causes
            ;				      //  a reset and app start.
    }
    putch(STK_INSYNC);
 18c:	84 e1       	ldi	r24, 0x14	; 20
 18e:	dc cf       	rjmp	.-72     	; 0x148 <putch>

00000190 <getNch>:
#endif

    return ch;
}

void getNch (uint8_t count) {
 190:	cf 93       	push	r28
 192:	c8 2f       	mov	r28, r24
    do getch(); while (--count);
 194:	e0 df       	rcall	.-64     	; 0x156 <getch>
 196:	c1 50       	subi	r28, 0x01	; 1
 198:	e9 f7       	brne	.-6      	; 0x194 <getNch+0x4>
    verifySpace();
}
 19a:	cf 91       	pop	r28
    return ch;
}

void getNch (uint8_t count) {
    do getch(); while (--count);
    verifySpace();
 19c:	f1 cf       	rjmp	.-30     	; 0x180 <verifySpace>

0000019e <do_nvmctrl>:
 19e:	68 30       	cpi	r22, 0x08	; 8
 * For example, to write a flash page:
 *
 */
static void do_nvmctrl(uint16_t address, uint8_t command, uint8_t data)  __attribute__ ((used));
static void do_nvmctrl (uint16_t address, uint8_t command, uint8_t data) {
     if (command <= NVMCTRL_CMD_gm) {
 1a0:	48 f4       	brcc	.+18     	; 0x1b4 <do_nvmctrl+0x16>
 1a2:	8d e9       	ldi	r24, 0x9D	; 157
        _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, command);
 1a4:	84 bf       	out	0x34, r24	; 52
 1a6:	60 93 00 10 	sts	0x1000, r22	; 0x801000 <__TEXT_REGION_LENGTH__+0x701000>
 1aa:	80 91 02 10 	lds	r24, 0x1002	; 0x801002 <__TEXT_REGION_LENGTH__+0x701002>
        while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
 1ae:	83 70       	andi	r24, 0x03	; 3
 1b0:	e1 f7       	brne	.-8      	; 0x1aa <do_nvmctrl+0xc>
 1b2:	08 95       	ret
 1b4:	fc 01       	movw	r30, r24
            ; // wait for flash and EEPROM not busy, just in case.
    } else {
        *(uint8_t *)address = data;
 1b6:	40 83       	st	Z, r20
 1b8:	08 95       	ret

Disassembly of section .application:

00000200 <app>:
#endif
void app() 
{
    uint8_t ch;
    
    ch = RSTCTRL.RSTFR;
 200:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    RSTCTRL.RSTFR = ch; // reset causes
 204:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    *(volatile uint16_t *)(&optiboot_version);   // reference the version
 208:	80 91 fe 01 	lds	r24, 0x01FE	; 0x8001fe <__TEXT_REGION_LENGTH__+0x7001fe>
 20c:	90 91 ff 01 	lds	r25, 0x01FF	; 0x8001ff <__TEXT_REGION_LENGTH__+0x7001ff>
#if defined (USERROW_LOGIC)
    BOOTLOADER_KEY_ADDR = 0x01;
 210:	81 e0       	ldi	r24, 0x01	; 1
 212:	80 93 1f 13 	sts	0x131F, r24	; 0x80131f <__TEXT_REGION_LENGTH__+0x70131f>
 *
 */
static void do_nvmctrl(uint16_t address, uint8_t command, uint8_t data)  __attribute__ ((used));
static void do_nvmctrl (uint16_t address, uint8_t command, uint8_t data) {
     if (command <= NVMCTRL_CMD_gm) {
        _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, command);
 216:	8d e9       	ldi	r24, 0x9D	; 157
 218:	93 e0       	ldi	r25, 0x03	; 3
 21a:	84 bf       	out	0x34, r24	; 52
 21c:	90 93 00 10 	sts	0x1000, r25	; 0x801000 <__TEXT_REGION_LENGTH__+0x701000>
        while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
 220:	80 91 02 10 	lds	r24, 0x1002	; 0x801002 <__TEXT_REGION_LENGTH__+0x701002>
 224:	83 70       	andi	r24, 0x03	; 3
 226:	e1 f7       	brne	.-8      	; 0x220 <app+0x20>
    //__asm__ __volatile__ ("jmp 0");    // similar to running off end of memory
    //BOOTLOADER_KEY_ADDR = 0xff;
    //_PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
    //while(NVMCTRL.STATUS & NVMCTRL_EEBUSY_bm)
    //    ;
    _PROTECTED_WRITE(RSTCTRL.SWRR, 1); // cause new reset
 228:	88 ed       	ldi	r24, 0xD8	; 216
 22a:	91 e0       	ldi	r25, 0x01	; 1
 22c:	84 bf       	out	0x34, r24	; 52
 22e:	90 93 41 00 	sts	0x0041, r25	; 0x800041 <__TEXT_REGION_LENGTH__+0x700041>
