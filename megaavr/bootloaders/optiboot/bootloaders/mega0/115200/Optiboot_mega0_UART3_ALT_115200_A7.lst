
bootloaders/mega0/115200/Optiboot_mega0_UART3_ALT_115200_A7.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00802800  00000346  000003fa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000346  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .application  0000002a  00000400  00000400  000003fc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .version      00000002  000003fe  000003fe  000003fa  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .fuse         00000009  00820000  00820000  00000426  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .comment      00000011  00000000  00000000  0000042f  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000038  00000000  00000000  00000440  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000008fe  00000000  00000000  00000478  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000021e  00000000  00000000  00000d76  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000003e4  00000000  00000000  00000f94  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000010c  00000000  00000000  00001378  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000006ff  00000000  00000000  00001484  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000001d0  00000000  00000000  00001b83  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000028  00000000  00000000  00001d53  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pre_main>:
/* everything that needs to run VERY early */
void pre_main (void) {
    // Allow convenient way of calling do_spm function - jump table,
    //   so entry to this function will always be here, indepedent
    //    of compilation, features, etc
    __asm__ __volatile__ (
   0:	01 c0       	rjmp	.+2      	; 0x4 <__zero_reg__+0x3>
   2:	77 c1       	rjmp	.+750    	; 0x2f2 <do_nvmctrl>
	...

00000006 <main>:
	"1:\n"
	);
}

/* main program starts here */
int main (void) {
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	25 97       	sbiw	r28, 0x05	; 5
   c:	cd bf       	out	0x3d, r28	; 61
   e:	de bf       	out	0x3e, r29	; 62
    //
    // Optiboot C code makes the following assumptions:
    //  No interrupts will execute
    //  SP points to RAMEND

    __asm__ __volatile__ ("clr __zero_reg__"); // known-zero required by avr-libc
  10:	11 24       	eor	r1, r1
#define RESET_EXTERNAL (RSTCTRL_EXTRF_bm|RSTCTRL_UPDIRF_bm|RSTCTRL_SWRF_bm)
#ifndef FANCY_RESET_LOGIC
  ch = RSTCTRL.RSTFR;   // get reset cause
  12:	80 e4       	ldi	r24, 0x40	; 64
  14:	90 e0       	ldi	r25, 0x00	; 0
  16:	fc 01       	movw	r30, r24
  18:	80 81       	ld	r24, Z
  1a:	89 83       	std	Y+1, r24	; 0x01
   * 11/14: NASTY bug - we also need to check for no reset flags being
   * set (ie, direct entry) and run bootloader in that case, otherwise
   * bootloader won't run, among other things, after fresh bootloading!
   */

  if (ch && (ch & RSTCTRL_WDRF_bm ||
  1c:	89 81       	ldd	r24, Y+1	; 0x01
  1e:	88 23       	and	r24, r24
  20:	d1 f0       	breq	.+52     	; 0x56 <__SREG__+0x17>
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	88 2f       	mov	r24, r24
  26:	90 e0       	ldi	r25, 0x00	; 0
  28:	88 70       	andi	r24, 0x08	; 8
  2a:	99 27       	eor	r25, r25
  2c:	89 2b       	or	r24, r25
  2e:	31 f4       	brne	.+12     	; 0x3c <__CCP__+0x8>
             (!(ch & (~(RSTCTRL_BORF_bm | RSTCTRL_PORF_bm)))))) {
  30:	89 81       	ldd	r24, Y+1	; 0x01
  32:	88 2f       	mov	r24, r24
  34:	90 e0       	ldi	r25, 0x00	; 0
  36:	8c 7f       	andi	r24, 0xFC	; 252
   * 11/14: NASTY bug - we also need to check for no reset flags being
   * set (ie, direct entry) and run bootloader in that case, otherwise
   * bootloader won't run, among other things, after fresh bootloading!
   */

  if (ch && (ch & RSTCTRL_WDRF_bm ||
  38:	89 2b       	or	r24, r25
  3a:	69 f4       	brne	.+26     	; 0x56 <__SREG__+0x17>
     * Dont bother trying to stuff it in r2, which requires heroic
     * effort to fish out we'll put it in GPIOR0 where it won't get
     * stomped on.
     */
    // __asm__ __volatile__ ("  mov r2, %0\n" :: "r" (ch));
    RSTCTRL.RSTFR = ch; //clear the reset causes before jumping to app...
  3c:	80 e4       	ldi	r24, 0x40	; 64
  3e:	90 e0       	ldi	r25, 0x00	; 0
  40:	29 81       	ldd	r18, Y+1	; 0x01
  42:	fc 01       	movw	r30, r24
  44:	20 83       	st	Z, r18
    GPIOR0 = ch; // but, stash the reset cause in GPIOR0 for use by app...
  46:	8c e1       	ldi	r24, 0x1C	; 28
  48:	90 e0       	ldi	r25, 0x00	; 0
  4a:	29 81       	ldd	r18, Y+1	; 0x01
  4c:	fc 01       	movw	r30, r24
  4e:	20 83       	st	Z, r18
    watchdogConfig(WDT_PERIOD_OFF_gc);
  50:	80 e0       	ldi	r24, 0x00	; 0
  52:	34 d1       	rcall	.+616    	; 0x2bc <watchdogConfig>
    __asm__ __volatile__(
  54:	d5 c1       	rjmp	.+938    	; 0x400 <__FUSE_REGION_LENGTH__>
  56:	a8 95       	wdr
        );
    }
  }
#endif // Fancy reset cause stuff

    watchdogReset();
  58:	84 e0       	ldi	r24, 0x04	; 4
    //_PROTECTED_WRITE(CLKCTRL.MCLKCTRLB, CLKCTRL_PDIV_6X_gc);  // full speed clock

    MYUART_TXPORT.DIR |= MYUART_TXPIN; // set TX pin to output
  5a:	90 e0       	ldi	r25, 0x00	; 0
  5c:	fc 01       	movw	r30, r24
  5e:	20 81       	ld	r18, Z
  60:	84 e0       	ldi	r24, 0x04	; 4
  62:	90 e0       	ldi	r25, 0x00	; 0
  64:	20 61       	ori	r18, 0x10	; 16
  66:	fc 01       	movw	r30, r24
  68:	20 83       	st	Z, r18
  6a:	84 e0       	ldi	r24, 0x04	; 4
    MYUART_TXPORT.OUT |= MYUART_TXPIN;  // and "1" as per datasheet
  6c:	90 e0       	ldi	r25, 0x00	; 0
  6e:	fc 01       	movw	r30, r24
  70:	21 81       	ldd	r18, Z+1	; 0x01
  72:	84 e0       	ldi	r24, 0x04	; 4
  74:	90 e0       	ldi	r25, 0x00	; 0
  76:	20 61       	ori	r18, 0x10	; 16
  78:	fc 01       	movw	r30, r24
  7a:	21 83       	std	Z+1, r18	; 0x01
  7c:	80 ee       	ldi	r24, 0xE0	; 224
#if defined (MYUART_PMUX_VAL)
    MYPMUX_REG = MYUART_PMUX_VAL;  // alternate pinout to use
  7e:	95 e0       	ldi	r25, 0x05	; 5
  80:	20 e4       	ldi	r18, 0x40	; 64
  82:	fc 01       	movw	r30, r24
  84:	22 83       	std	Z+2, r18	; 0x02
  86:	82 e8       	ldi	r24, 0x82	; 130
#endif
    if ((FUSE_OSCCFG & FUSE_FREQSEL_gm) == FREQSEL_16MHZ_gc) {
  88:	92 e1       	ldi	r25, 0x12	; 18
  8a:	fc 01       	movw	r30, r24
  8c:	80 81       	ld	r24, Z
  8e:	88 2f       	mov	r24, r24
  90:	90 e0       	ldi	r25, 0x00	; 0
  92:	83 70       	andi	r24, 0x03	; 3
  94:	99 27       	eor	r25, r25
  96:	01 97       	sbiw	r24, 0x01	; 1
  98:	41 f4       	brne	.+16     	; 0xaa <__SREG__+0x6b>
  9a:	80 e6       	ldi	r24, 0x60	; 96
	    MYUART.BAUD = BAUD_SETTING_16;
  9c:	98 e0       	ldi	r25, 0x08	; 8
  9e:	2c e5       	ldi	r18, 0x5C	; 92
  a0:	30 e0       	ldi	r19, 0x00	; 0
  a2:	fc 01       	movw	r30, r24
  a4:	20 87       	std	Z+8, r18	; 0x08
  a6:	31 87       	std	Z+9, r19	; 0x09
  a8:	07 c0       	rjmp	.+14     	; 0xb8 <__SREG__+0x79>
  aa:	80 e6       	ldi	r24, 0x60	; 96
    } else {
	    MYUART.BAUD = BAUD_SETTING_20;//694;
  ac:	98 e0       	ldi	r25, 0x08	; 8
  ae:	23 e7       	ldi	r18, 0x73	; 115
  b0:	30 e0       	ldi	r19, 0x00	; 0
  b2:	fc 01       	movw	r30, r24
  b4:	20 87       	std	Z+8, r18	; 0x08
  b6:	31 87       	std	Z+9, r19	; 0x09
  b8:	80 e6       	ldi	r24, 0x60	; 96
    }
    MYUART.DBGCTRL = 1;  // run during debug
  ba:	98 e0       	ldi	r25, 0x08	; 8
  bc:	21 e0       	ldi	r18, 0x01	; 1
  be:	fc 01       	movw	r30, r24
  c0:	23 87       	std	Z+11, r18	; 0x0b
  c2:	80 e6       	ldi	r24, 0x60	; 96
    MYUART.CTRLC = (USART_CHSIZE_gm & USART_CHSIZE_8BIT_gc);  // Async, Parity Disabled, 1 StopBit
  c4:	98 e0       	ldi	r25, 0x08	; 8
  c6:	23 e0       	ldi	r18, 0x03	; 3
  c8:	fc 01       	movw	r30, r24
  ca:	27 83       	std	Z+7, r18	; 0x07
  cc:	80 e6       	ldi	r24, 0x60	; 96
    MYUART.CTRLA = 0;  // Interrupts: all off
  ce:	98 e0       	ldi	r25, 0x08	; 8
  d0:	fc 01       	movw	r30, r24
  d2:	15 82       	std	Z+5, r1	; 0x05
  d4:	80 e6       	ldi	r24, 0x60	; 96
    MYUART.CTRLB = USART_RXEN_bm | USART_TXEN_bm;
  d6:	98 e0       	ldi	r25, 0x08	; 8
  d8:	20 ec       	ldi	r18, 0xC0	; 192
  da:	fc 01       	movw	r30, r24
  dc:	26 83       	std	Z+6, r18	; 0x06

    // Set up watchdog to trigger after a bit
    //  (nominally:, 1s for autoreset, longer for manual)
    watchdogConfig(WDTPERIOD);
  de:	88 e0       	ldi	r24, 0x08	; 8
  e0:	ed d0       	rcall	.+474    	; 0x2bc <watchdogConfig>
#endif

    /* Forever loop: exits by causing WDT reset */
    for (;;) {
        /* get character from UART */
        ch = getch();
  e2:	a5 d0       	rcall	.+330    	; 0x22e <getch>
  e4:	89 83       	std	Y+1, r24	; 0x01

        if(ch == STK_GET_PARAMETER) {
  e6:	89 81       	ldd	r24, Y+1	; 0x01
  e8:	81 34       	cpi	r24, 0x41	; 65
            which = getch();
  ea:	b1 f4       	brne	.+44     	; 0x118 <__SREG__+0xd9>
  ec:	a0 d0       	rcall	.+320    	; 0x22e <getch>
  ee:	8b 83       	std	Y+3, r24	; 0x03
            verifySpace();
  f0:	d5 d0       	rcall	.+426    	; 0x29c <verifySpace>
            /*
            * Send optiboot version as "SW version"
            * Note that the references to memory are optimized away.
            */
            if (which == STK_SW_MINOR) {
  f2:	8b 81       	ldd	r24, Y+3	; 0x03
  f4:	82 38       	cpi	r24, 0x82	; 130
  f6:	21 f4       	brne	.+8      	; 0x100 <__SREG__+0xc1>
                putch(optiboot_version & 0xFF);
  f8:	80 e0       	ldi	r24, 0x00	; 0
  fa:	99 e0       	ldi	r25, 0x09	; 9
  fc:	7d d0       	rcall	.+250    	; 0x1f8 <putch>
  fe:	79 c0       	rjmp	.+242    	; 0x1f2 <__SREG__+0x1b3>
 100:	8b 81       	ldd	r24, Y+3	; 0x03
            } else if (which == STK_SW_MAJOR) {
 102:	81 38       	cpi	r24, 0x81	; 129
 104:	31 f4       	brne	.+12     	; 0x112 <__SREG__+0xd3>
                putch(optiboot_version >> 8);
 106:	80 e0       	ldi	r24, 0x00	; 0
 108:	99 e0       	ldi	r25, 0x09	; 9
 10a:	89 2f       	mov	r24, r25
 10c:	99 27       	eor	r25, r25
 10e:	74 d0       	rcall	.+232    	; 0x1f8 <putch>
            } else {
            /*
            * GET PARAMETER returns a generic 0x03 reply for
            * other parameters - enough to keep Avrdude happy
            */
                putch(0x03);
 110:	70 c0       	rjmp	.+224    	; 0x1f2 <__SREG__+0x1b3>
 112:	83 e0       	ldi	r24, 0x03	; 3
        }
        else if(ch == STK_SET_DEVICE_EXT) {
            // SET DEVICE EXT is ignored
            getNch(5);
        }*/ 
        else if(ch == STK_LOAD_ADDRESS) {
 114:	71 d0       	rcall	.+226    	; 0x1f8 <putch>
 116:	6d c0       	rjmp	.+218    	; 0x1f2 <__SREG__+0x1b3>
 118:	89 81       	ldd	r24, Y+1	; 0x01
            // LOAD ADDRESS
            address.bytes[0] = getch();
 11a:	85 35       	cpi	r24, 0x55	; 85
 11c:	31 f4       	brne	.+12     	; 0x12a <__SREG__+0xeb>
            address.bytes[1] = getch();
 11e:	87 d0       	rcall	.+270    	; 0x22e <getch>
 120:	08 2f       	mov	r16, r24
            // ToDo: will there be mega-0 chips with >128k of RAM?
    /*          UPDI chips apparently have byte-addressable FLASH ?
            address.word *= 2; // Convert from word address to byte address
    */
            verifySpace();
 122:	85 d0       	rcall	.+266    	; 0x22e <getch>
 124:	18 2f       	mov	r17, r24
 126:	ba d0       	rcall	.+372    	; 0x29c <verifySpace>
            getNch(4);
            putch(0x00);
#endif
        }
        /* Write memory, length is big endian and is in bytes */
        else if(ch == STK_PROG_PAGE) {
 128:	64 c0       	rjmp	.+200    	; 0x1f2 <__SREG__+0x1b3>
 12a:	89 81       	ldd	r24, Y+1	; 0x01
 12c:	84 36       	cpi	r24, 0x64	; 100
 12e:	09 f0       	breq	.+2      	; 0x132 <__SREG__+0xf3>
            // PROGRAM PAGE - any kind of page!

            GETLENGTH(length);
 130:	42 c0       	rjmp	.+132    	; 0x1b6 <__SREG__+0x177>
 132:	7d d0       	rcall	.+250    	; 0x22e <getch>
 134:	7c d0       	rcall	.+248    	; 0x22e <getch>
 136:	f8 2e       	mov	r15, r24
 138:	7a d0       	rcall	.+244    	; 0x22e <getch>
            desttype = getch();
 13a:	8a 83       	std	Y+2, r24	; 0x02
 13c:	8a 81       	ldd	r24, Y+2	; 0x02

            if (desttype == 'F') {
 13e:	86 34       	cpi	r24, 0x46	; 70
 140:	21 f4       	brne	.+8      	; 0x14a <__SREG__+0x10b>
 142:	c8 01       	movw	r24, r16
                address.word += MAPPED_PROGMEM_START;
 144:	90 5c       	subi	r25, 0xC0	; 192
 146:	8c 01       	movw	r16, r24
 148:	03 c0       	rjmp	.+6      	; 0x150 <__SREG__+0x111>
            } else {
                address.word += MAPPED_EEPROM_START;
 14a:	c8 01       	movw	r24, r16
 14c:	9c 5e       	subi	r25, 0xEC	; 236
 14e:	8c 01       	movw	r16, r24
            }
            // TODO: user row?

            do {
                *(address.bptr++) = getch();
 150:	68 01       	movw	r12, r16
 152:	c6 01       	movw	r24, r12
 154:	01 96       	adiw	r24, 0x01	; 1
 156:	8c 01       	movw	r16, r24
 158:	6a d0       	rcall	.+212    	; 0x22e <getch>
 15a:	f6 01       	movw	r30, r12
 15c:	80 83       	st	Z, r24
 15e:	fa 94       	dec	r15
            } while (--length);
 160:	ff 20       	and	r15, r15
 162:	b1 f7       	brne	.-20     	; 0x150 <__SREG__+0x111>
 164:	9b d0       	rcall	.+310    	; 0x29c <verifySpace>

            // Read command terminator, start reply
            verifySpace();
 166:	00 00       	nop
 168:	80 e0       	ldi	r24, 0x00	; 0

            while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
 16a:	90 e1       	ldi	r25, 0x10	; 16
 16c:	fc 01       	movw	r30, r24
 16e:	82 81       	ldd	r24, Z+2	; 0x02
 170:	88 2f       	mov	r24, r24
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	83 70       	andi	r24, 0x03	; 3
 176:	99 27       	eor	r25, r25
 178:	89 2b       	or	r24, r25
 17a:	b1 f7       	brne	.-20     	; 0x168 <__SREG__+0x129>
 17c:	8d e9       	ldi	r24, 0x9D	; 157
 17e:	93 e0       	ldi	r25, 0x03	; 3
            ; // wait for flash and EEPROM not busy, just in case.

            /*
            * Actually Write the buffer to flash (and wait for it to finish.) */
            
            _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_PAGEERASEWRITE_gc);
 180:	84 bf       	out	0x34, r24	; 52
 182:	90 93 00 10 	sts	0x1000, r25	; 0x801000 <__TEXT_REGION_LENGTH__+0x701000>
 186:	00 00       	nop
 188:	80 e0       	ldi	r24, 0x00	; 0
            while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
 18a:	90 e1       	ldi	r25, 0x10	; 16
 18c:	fc 01       	movw	r30, r24
 18e:	82 81       	ldd	r24, Z+2	; 0x02
 190:	88 2f       	mov	r24, r24
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	83 70       	andi	r24, 0x03	; 3
 196:	99 27       	eor	r25, r25
 198:	89 2b       	or	r24, r25
 19a:	b1 f7       	brne	.-20     	; 0x188 <__SREG__+0x149>
 19c:	80 e0       	ldi	r24, 0x00	; 0
            ; // wait for flash and EEPROM not busy, just in case.
            if (NVMCTRL.STATUS & NVMCTRL_WRERROR_bm)
 19e:	90 e1       	ldi	r25, 0x10	; 16
 1a0:	fc 01       	movw	r30, r24
 1a2:	82 81       	ldd	r24, Z+2	; 0x02
 1a4:	88 2f       	mov	r24, r24
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	84 70       	andi	r24, 0x04	; 4
 1aa:	99 27       	eor	r25, r25
            {
                putch(STK_FAILED);
 1ac:	89 2b       	or	r24, r25
 1ae:	09 f1       	breq	.+66     	; 0x1f2 <__SREG__+0x1b3>
 1b0:	81 e1       	ldi	r24, 0x11	; 17
 1b2:	22 d0       	rcall	.+68     	; 0x1f8 <putch>
            }
            
        }
        /* Read memory block mode, length is big endian. */ 
        else if(ch == STK_READ_PAGE) {
 1b4:	1e c0       	rjmp	.+60     	; 0x1f2 <__SREG__+0x1b3>
 1b6:	89 81       	ldd	r24, Y+1	; 0x01
 1b8:	84 37       	cpi	r24, 0x74	; 116
            GETLENGTH(length);
 1ba:	d9 f4       	brne	.+54     	; 0x1f2 <__SREG__+0x1b3>
 1bc:	38 d0       	rcall	.+112    	; 0x22e <getch>
 1be:	37 d0       	rcall	.+110    	; 0x22e <getch>
 1c0:	f8 2e       	mov	r15, r24
 1c2:	35 d0       	rcall	.+106    	; 0x22e <getch>

            desttype = getch();
 1c4:	8a 83       	std	Y+2, r24	; 0x02
 1c6:	6a d0       	rcall	.+212    	; 0x29c <verifySpace>

            verifySpace();
 1c8:	8a 81       	ldd	r24, Y+2	; 0x02
 1ca:	86 34       	cpi	r24, 0x46	; 70
            if (desttype == 'F') {
 1cc:	21 f4       	brne	.+8      	; 0x1d6 <__SREG__+0x197>
 1ce:	c8 01       	movw	r24, r16
                address.word += MAPPED_PROGMEM_START;
 1d0:	90 5c       	subi	r25, 0xC0	; 192
 1d2:	8c 01       	movw	r16, r24
 1d4:	03 c0       	rjmp	.+6      	; 0x1dc <__SREG__+0x19d>
 1d6:	c8 01       	movw	r24, r16
            } else {
                address.word += MAPPED_EEPROM_START;
 1d8:	9c 5e       	subi	r25, 0xEC	; 236
 1da:	8c 01       	movw	r16, r24
 1dc:	c8 01       	movw	r24, r16
            }
            // TODO: user row?

            do {
                putch(*(address.bptr++));
 1de:	9c 01       	movw	r18, r24
 1e0:	2f 5f       	subi	r18, 0xFF	; 255
 1e2:	3f 4f       	sbci	r19, 0xFF	; 255
 1e4:	89 01       	movw	r16, r18
 1e6:	fc 01       	movw	r30, r24
 1e8:	80 81       	ld	r24, Z
 1ea:	06 d0       	rcall	.+12     	; 0x1f8 <putch>
 1ec:	fa 94       	dec	r15
 1ee:	ff 20       	and	r15, r15
            } while (--length);
 1f0:	a9 f7       	brne	.-22     	; 0x1dc <__SREG__+0x19d>
 1f2:	80 e1       	ldi	r24, 0x10	; 16
 1f4:	01 d0       	rcall	.+2      	; 0x1f8 <putch>
        }
        else {
            // This covers the response to commands like STK_ENTER_PROGMODE
            verifySpace();
        }*/
        putch(STK_OK);
 1f6:	75 cf       	rjmp	.-278    	; 0xe2 <__SREG__+0xa3>

000001f8 <putch>:
 1f8:	cf 93       	push	r28
 1fa:	df 93       	push	r29
#endif

    /* Forever loop: exits by causing WDT reset */
    for (;;) {
        /* get character from UART */
        ch = getch();
 1fc:	1f 92       	push	r1
        }*/
        putch(STK_OK);
    }
}

void putch (char ch) {
 1fe:	cd b7       	in	r28, 0x3d	; 61
 200:	de b7       	in	r29, 0x3e	; 62
 202:	89 83       	std	Y+1, r24	; 0x01
    while (0 == (MYUART.STATUS & USART_DREIF_bm))
 204:	00 00       	nop
 206:	80 e6       	ldi	r24, 0x60	; 96
 208:	98 e0       	ldi	r25, 0x08	; 8
 20a:	fc 01       	movw	r30, r24
 20c:	84 81       	ldd	r24, Z+4	; 0x04
 20e:	88 2f       	mov	r24, r24
 210:	90 e0       	ldi	r25, 0x00	; 0
 212:	80 72       	andi	r24, 0x20	; 32
 214:	99 27       	eor	r25, r25
 216:	89 2b       	or	r24, r25
 218:	b1 f3       	breq	.-20     	; 0x206 <putch+0xe>
	;
    MYUART.TXDATAL = ch;
 21a:	80 e6       	ldi	r24, 0x60	; 96
 21c:	98 e0       	ldi	r25, 0x08	; 8
 21e:	29 81       	ldd	r18, Y+1	; 0x01
 220:	fc 01       	movw	r30, r24
 222:	22 83       	std	Z+2, r18	; 0x02
}
 224:	00 00       	nop
 226:	0f 90       	pop	r0
 228:	df 91       	pop	r29
 22a:	cf 91       	pop	r28
 22c:	08 95       	ret

0000022e <getch>:

//#define ECHO

uint8_t getch (void) {
 22e:	cf 93       	push	r28
 230:	df 93       	push	r29
 232:	00 d0       	rcall	.+0      	; 0x234 <getch+0x6>
 234:	cd b7       	in	r28, 0x3d	; 61
 236:	de b7       	in	r29, 0x3e	; 62
    uint8_t ch, flags;
    while (!(MYUART.STATUS & USART_RXCIF_bm))
 238:	00 00       	nop
 23a:	80 e6       	ldi	r24, 0x60	; 96
 23c:	98 e0       	ldi	r25, 0x08	; 8
 23e:	fc 01       	movw	r30, r24
 240:	84 81       	ldd	r24, Z+4	; 0x04
 242:	88 23       	and	r24, r24
 244:	d4 f7       	brge	.-12     	; 0x23a <getch+0xc>
	;
    flags = MYUART.RXDATAH;
 246:	80 e6       	ldi	r24, 0x60	; 96
 248:	98 e0       	ldi	r25, 0x08	; 8
 24a:	fc 01       	movw	r30, r24
 24c:	81 81       	ldd	r24, Z+1	; 0x01
 24e:	89 83       	std	Y+1, r24	; 0x01
    ch = MYUART.RXDATAL;
 250:	80 e6       	ldi	r24, 0x60	; 96
 252:	98 e0       	ldi	r25, 0x08	; 8
 254:	fc 01       	movw	r30, r24
 256:	80 81       	ld	r24, Z
 258:	8a 83       	std	Y+2, r24	; 0x02
#ifdef ECHO
    putch(ch);
#endif
    if ((flags & USART_FERR_bm) == 0)
 25a:	89 81       	ldd	r24, Y+1	; 0x01
 25c:	88 2f       	mov	r24, r24
 25e:	90 e0       	ldi	r25, 0x00	; 0
 260:	84 70       	andi	r24, 0x04	; 4
 262:	99 27       	eor	r25, r25
 264:	89 2b       	or	r24, r25
 266:	09 f4       	brne	.+2      	; 0x26a <getch+0x3c>
	    watchdogReset();
 268:	a8 95       	wdr
#ifdef LED_DATA_FLASH
    LED_PORT.IN |= LED;
#endif

    return ch;
 26a:	8a 81       	ldd	r24, Y+2	; 0x02
}
 26c:	0f 90       	pop	r0
 26e:	0f 90       	pop	r0
 270:	df 91       	pop	r29
 272:	cf 91       	pop	r28
 274:	08 95       	ret

00000276 <getNch>:

void getNch (uint8_t count) {
 276:	cf 93       	push	r28
 278:	df 93       	push	r29
 27a:	1f 92       	push	r1
 27c:	cd b7       	in	r28, 0x3d	; 61
 27e:	de b7       	in	r29, 0x3e	; 62
 280:	89 83       	std	Y+1, r24	; 0x01
    do getch(); while (--count);
 282:	d5 df       	rcall	.-86     	; 0x22e <getch>
 284:	89 81       	ldd	r24, Y+1	; 0x01
 286:	81 50       	subi	r24, 0x01	; 1
 288:	89 83       	std	Y+1, r24	; 0x01
 28a:	89 81       	ldd	r24, Y+1	; 0x01
 28c:	88 23       	and	r24, r24
 28e:	c9 f7       	brne	.-14     	; 0x282 <getNch+0xc>
    verifySpace();
 290:	05 d0       	rcall	.+10     	; 0x29c <verifySpace>
 292:	00 00       	nop
}
 294:	0f 90       	pop	r0
 296:	df 91       	pop	r29
 298:	cf 91       	pop	r28
 29a:	08 95       	ret

0000029c <verifySpace>:
 29c:	cf 93       	push	r28

void verifySpace () {
 29e:	df 93       	push	r29
 2a0:	cd b7       	in	r28, 0x3d	; 61
 2a2:	de b7       	in	r29, 0x3e	; 62
    if (getch() != CRC_EOP) {
 2a4:	c4 df       	rcall	.-120    	; 0x22e <getch>
 2a6:	80 32       	cpi	r24, 0x20	; 32
 2a8:	19 f0       	breq	.+6      	; 0x2b0 <verifySpace+0x14>
        watchdogConfig(WDT_PERIOD_8CLK_gc);    // shorten WD timeout
 2aa:	81 e0       	ldi	r24, 0x01	; 1
 2ac:	07 d0       	rcall	.+14     	; 0x2bc <watchdogConfig>
        while (1)			      // and busy-loop so that WD causes
 2ae:	ff cf       	rjmp	.-2      	; 0x2ae <verifySpace+0x12>
            ;				      //  a reset and app start.
    }
    putch(STK_INSYNC);
 2b0:	84 e1       	ldi	r24, 0x14	; 20
 2b2:	a2 df       	rcall	.-188    	; 0x1f8 <putch>
 2b4:	00 00       	nop
}
 2b6:	df 91       	pop	r29
 2b8:	cf 91       	pop	r28
 2ba:	08 95       	ret

000002bc <watchdogConfig>:
 2bc:	cf 93       	push	r28

/*
 * Change the watchdog configuration.
 *  Could be a new timeout, could be off...
 */
void watchdogConfig (uint8_t x) {
 2be:	df 93       	push	r29
 2c0:	1f 92       	push	r1
 2c2:	cd b7       	in	r28, 0x3d	; 61
 2c4:	de b7       	in	r29, 0x3e	; 62
 2c6:	89 83       	std	Y+1, r24	; 0x01
 2c8:	00 00       	nop
    while(WDT.STATUS & WDT_SYNCBUSY_bm)
 2ca:	80 e0       	ldi	r24, 0x00	; 0
 2cc:	91 e0       	ldi	r25, 0x01	; 1
 2ce:	fc 01       	movw	r30, r24
 2d0:	81 81       	ldd	r24, Z+1	; 0x01
 2d2:	88 2f       	mov	r24, r24
 2d4:	90 e0       	ldi	r25, 0x00	; 0
 2d6:	81 70       	andi	r24, 0x01	; 1
 2d8:	99 27       	eor	r25, r25
 2da:	89 2b       	or	r24, r25
 2dc:	b1 f7       	brne	.-20     	; 0x2ca <watchdogConfig+0xe>
 2de:	88 ed       	ldi	r24, 0xD8	; 216
	;  // Busy wait for sycnhronization is required!
    _PROTECTED_WRITE(WDT.CTRLA, x);
 2e0:	99 81       	ldd	r25, Y+1	; 0x01
 2e2:	84 bf       	out	0x34, r24	; 52
 2e4:	90 93 00 01 	sts	0x0100, r25	; 0x800100 <__TEXT_REGION_LENGTH__+0x700100>
 2e8:	00 00       	nop
}
 2ea:	0f 90       	pop	r0
 2ec:	df 91       	pop	r29
 2ee:	cf 91       	pop	r28
 2f0:	08 95       	ret

000002f2 <do_nvmctrl>:
 2f2:	cf 93       	push	r28
 *
 * For example, to write a flash page:
 *
 */
static void do_nvmctrl(uint16_t address, uint8_t command, uint8_t data)  __attribute__ ((used));
static void do_nvmctrl (uint16_t address, uint8_t command, uint8_t data) {
 2f4:	df 93       	push	r29
 2f6:	00 d0       	rcall	.+0      	; 0x2f8 <do_nvmctrl+0x6>
 2f8:	00 d0       	rcall	.+0      	; 0x2fa <do_nvmctrl+0x8>
 2fa:	cd b7       	in	r28, 0x3d	; 61
 2fc:	de b7       	in	r29, 0x3e	; 62
 2fe:	89 83       	std	Y+1, r24	; 0x01
 300:	9a 83       	std	Y+2, r25	; 0x02
 302:	6b 83       	std	Y+3, r22	; 0x03
 304:	4c 83       	std	Y+4, r20	; 0x04
 306:	8b 81       	ldd	r24, Y+3	; 0x03
     if (command <= NVMCTRL_CMD_gm) {
 308:	88 30       	cpi	r24, 0x08	; 8
 30a:	88 f4       	brcc	.+34     	; 0x32e <do_nvmctrl+0x3c>
 30c:	8d e9       	ldi	r24, 0x9D	; 157
        _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, command);
 30e:	9b 81       	ldd	r25, Y+3	; 0x03
 310:	84 bf       	out	0x34, r24	; 52
 312:	90 93 00 10 	sts	0x1000, r25	; 0x801000 <__TEXT_REGION_LENGTH__+0x701000>
 316:	00 00       	nop
        while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
 318:	80 e0       	ldi	r24, 0x00	; 0
 31a:	90 e1       	ldi	r25, 0x10	; 16
 31c:	fc 01       	movw	r30, r24
 31e:	82 81       	ldd	r24, Z+2	; 0x02
 320:	88 2f       	mov	r24, r24
 322:	90 e0       	ldi	r25, 0x00	; 0
 324:	83 70       	andi	r24, 0x03	; 3
 326:	99 27       	eor	r25, r25
 328:	89 2b       	or	r24, r25
 32a:	b1 f7       	brne	.-20     	; 0x318 <do_nvmctrl+0x26>
 32c:	05 c0       	rjmp	.+10     	; 0x338 <do_nvmctrl+0x46>
            ; // wait for flash and EEPROM not busy, just in case.
    } else {
        *(uint8_t *)address = data;
    }
}
 32e:	89 81       	ldd	r24, Y+1	; 0x01
     if (command <= NVMCTRL_CMD_gm) {
        _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, command);
        while (NVMCTRL.STATUS & (NVMCTRL_FBUSY_bm|NVMCTRL_EEBUSY_bm))
            ; // wait for flash and EEPROM not busy, just in case.
    } else {
        *(uint8_t *)address = data;
 330:	9a 81       	ldd	r25, Y+2	; 0x02
 332:	2c 81       	ldd	r18, Y+4	; 0x04
 334:	fc 01       	movw	r30, r24
 336:	20 83       	st	Z, r18
 338:	00 00       	nop
    }
}
 33a:	24 96       	adiw	r28, 0x04	; 4
 33c:	cd bf       	out	0x3d, r28	; 61
 33e:	de bf       	out	0x3e, r29	; 62
 340:	df 91       	pop	r29
 342:	cf 91       	pop	r28
 344:	08 95       	ret

Disassembly of section .application:

00000400 <app>:
      __attribute__((naked)) app();
void app() 
{
    uint8_t ch;
    
    ch = RSTCTRL.RSTFR;
 400:	80 e4       	ldi	r24, 0x40	; 64
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	fc 01       	movw	r30, r24
 406:	10 81       	ld	r17, Z
    RSTCTRL.RSTFR = ch; // reset causes
 408:	80 e4       	ldi	r24, 0x40	; 64
 40a:	90 e0       	ldi	r25, 0x00	; 0
 40c:	fc 01       	movw	r30, r24
 40e:	10 83       	st	Z, r17
    *(volatile uint16_t *)(&optiboot_version);   // reference the version
 410:	8e ef       	ldi	r24, 0xFE	; 254
 412:	93 e0       	ldi	r25, 0x03	; 3
 414:	fc 01       	movw	r30, r24
 416:	80 81       	ld	r24, Z
 418:	91 81       	ldd	r25, Z+1	; 0x01
    do_nvmctrl(0, NVMCTRL_CMD_PAGEBUFCLR_gc, 0); // reference this function!    
 41a:	40 e0       	ldi	r20, 0x00	; 0
 41c:	64 e0       	ldi	r22, 0x04	; 4
 41e:	80 e0       	ldi	r24, 0x00	; 0
 420:	90 e0       	ldi	r25, 0x00	; 0
 422:	67 df       	rcall	.-306    	; 0x2f2 <do_nvmctrl>
    //watchdogConfig(WDT_PERIOD_8CLK_gc);    // shorten WD timeout
    //while (1)			      // and busy-loop so that WD causes
    //    ;				      //  a reset and app start.
    __asm__ __volatile__ ("jmp 0");    // similar to running off end of memory
 424:	0c 94 00 00 	jmp	0	; 0x0 <__tmp_reg__>
	...
